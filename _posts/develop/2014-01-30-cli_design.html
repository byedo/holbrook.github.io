---
tags:
  - CLI
  - 设计
  - python
layout: post
title: 命令行界面(CLI)设计
---
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 命令行界面是否过时</a></li>
<li><a href="#sec-2">2. 命令行界面的类型</a></li>
<li><a href="#sec-3">3. CLI世界的潜规则</a></li>
<li><a href="#sec-4">4. CLI支持库</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 命令行界面是否过时</h2>
<div class="outline-text-2" id="text-1">
<p>
答案是：不会的！
</p>

<p>
1965年<a href="http://en.wikipedia.org/wiki/OS/360_and_successors">OS/360</a>的发布标志着与硬件分离的“通用”操作系统的出现。
</p>

<p>
尽管8年后的1973年出现了<a href="http://en.wikipedia.org/wiki/Xerox_Alto">图形界面程序</a>，
16年后的1981年出现了<a href="http://en.wikipedia.org/wiki/Xerox_Star">图形界面的操作系统</a>，
但是在此之后，至今三十几年过去了，图形界面(GUI)仍无法取代命令行界面(CLI)。
</p>

<p>
有什么理由可以说，图形界面终将取代命令行界面呢？
</p>

<p>
不管是传统的linux“神器”，如find, grep, curl, netcat, xargs, rsync,
screen，awk, vi, emacs， 还是让人惊叹的新作，如maven, git,
salt，都有着强大的命令行界面。甚至你会有一种感觉：
为这些软件设计图形界面根本就是画蛇添足。
</p>

<p>
命令行界面的优势在于：
</p>

<ul class="org-ul">
<li>效率高
</li>
</ul>

<p>
鼠标操作是最简单，同时也是最笨拙的操作
</p>

<ul class="org-ul">
<li>更专注
</li>
</ul>

<p>
鼠标操作容易分心
</p>

<ul class="org-ul">
<li>速度快
</li>
</ul>

<p>
CLI程序需要的资源少，启动和执行速度更快
</p>

<ul class="org-ul">
<li>易远程
</li>
</ul>

<p>
ssh、telnet的连接比vnc、remote desktop等更容易
</p>

<ul class="org-ul">
<li>自动化
</li>
</ul>

<p>
CLI不仅可以给人使用，也适用于自动化脚本
</p>

<ul class="org-ul">
<li>zhuangbility
</li>
</ul>

<p>
^{o}
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 命令行界面的类型</h2>
<div class="outline-text-2" id="text-2">
<p>
按照复杂程度，命令行界面可以分为：
</p>

<ul class="org-ul">
<li>非交互式
</li>
</ul>

<p>
一次性输入所有的参数，程序执行期间不需要用户的干预。这是最常见的命令行界面形式。
</p>

<ul class="org-ul">
<li>基于行的交互
</li>
</ul>

<p>
在执行过程中，需要用户输入一些内容，比如确认信息、路径参数等。
</p>

<p>
由于用户交互会使程序难以用于自动化脚本，所以这种命令行界面并不多见，常用于基于命令行的安装程序。
</p>

<ul class="org-ul">
<li>文本用户界面
</li>
</ul>

<p>
类似于图形用户界面，没有明确的执行流程，完全由用户控制程序的执行步骤。比如vi和emacs。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> CLI世界的潜规则</h2>
<div class="outline-text-2" id="text-3">
<p>
为了使你的CLI程序不会显得格格不入，在设计CLI程序时要遵守一些潜规则。
</p>

<ul class="org-ul">
<li>良好命名
</li>

<li>容易理解
</li>
<li>名字要短
</li>
<li>容易记忆
</li>

<li>必备选项
</li>
</ul>

<p>
所有的命令行工具都应该提供=-v/&#x2013;version=和=-h/&#x2013;help=选项。
</p>

<ul class="org-ul">
<li>保持安静
</li>
</ul>

<p>
程序的输出要"恰到好处"，让用户/其他程序明确知道必要的信息，又不过分“啰嗦”。过多的输出即会浪费系统资源和带宽，也会让用户感觉不舒服，更重要的是会使得其他程序的处理逻辑变得复杂。以下的原则有利于保持安静：
</p>

<ul class="org-ul">
<li>不要输出无关的信息，比如版本号、作者名&#x2014;&#x2014;除非用户要求
</li>
<li>对于很明确的结果，不需要再提醒用户。只应提示例外(exception)情况
</li>
<li>不需要告诉用户输出的是什么东西&#x2014;&#x2014;用户会知道的
</li>
<li>如有必要，可以提供=-v/&#x2013;verbose=和=-q/&#x2013;quiet=选项，供用户选择
</li>

<li>明确要求
</li>
</ul>

<p>
在基于行的交互式CLI中，需要用户输入时要给出明确的提示，比如：
</p>

<p>
<code>Do you really want to do this (y/n)?</code>
</p>

<p>
<code>Enter a date (YYYY-MM-DD):</code>
</p>

<ul class="org-ul">
<li>支持管道
</li>
</ul>

<p>
程序应该支持从管道或文件重定向中读取数据：
</p>

<ul class="org-ul">
<li>如果文件名作为参数传递给程序，就读取文件的内容作为输入
</li>
<li>如果没有提供这样的参数，就从标准输入中读取，一直到 CTRL+D
</li>

<li>功能单一
</li>
</ul>

<p>
UNIX哲学中重要的一条原则就是：每个程序只做一件事情，并把它做好。
</p>

<p>
复杂的功能通过程序间的配合完成，而为了与其他的程序配合，要尽量支持管道和重定向。
</p>

<p>
既然“只做一件事”，就要“做好一件事”。
</p>

<ul class="org-ul">
<li>遵循惯例
</li>
</ul>

<p>
UNIX中命令行参数会有一些惯例，比如=-=后面的单字母选项可以连用（如=ls -Al=),
=&#x2013;=后面使用多字母选项等；此外，遵循已经被广泛使用的命令的参数，也会容易被接受。
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> CLI支持库</h2>
<div class="outline-text-2" id="text-4">
<p>
CLI是如此重要，以至于很多语言/平台都提供了开发CLI的支持库，比如：
</p>

<ul class="org-ul">
<li>python的optparse和argparse

<p>
argparse更先进，旨在替代optparse，但是从python2.7开始才支持。如果希望在比较旧的linux上运行(通常支持python2.4)，最好还是使用optparse。
</p>
</li>

<li>java的Apache Commons CLI
</li>
<li>Apache karaf的karaf-command-archetype
</li>
</ul>
</div>
</div>
